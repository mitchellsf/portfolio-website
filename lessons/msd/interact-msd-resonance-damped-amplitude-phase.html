<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Damped Forced Response - Amplitude & Phase vs Frequency Ratio</title>
  <style>
    :root{
      --bg: #ffffff;
      --fg: #000000;
      --grid: rgba(0,0,0,0.18);
      --axis: rgba(0,0,0,0.95);
      --muted: rgba(0,0,0,0.70);

      /* sliders */
      --track: #a9cff2;
      --thumb: #0c5a78;
      --thumb-ring: #08394b;
      --pl: 80px;   /* left padding */
      --lw: 30px;   /* label width */
      --vw: 70px;   /* value width */
      --pr: 20px;   /* right padding */

      /* font sizes */
      --ui-font: 24px;
      --tick-font: 20px;
      --axis-font: 24px;
    }

    html, body { height: auto; }
    body{
      margin:0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      justify-content:center;
      align-items:flex-start;
    }

    .wrap{
      width: min(980px, 94vw);
      padding: 22px 10px 26px;
      box-sizing: border-box;
    }

    .plot-card{
      width: 100%;
      display:flex;
      justify-content:center;
      align-items:center;
      padding: 0 0 0px;
      box-sizing: border-box;
    }

    canvas{
      width: 100%;
      aspect-ratio: 16 / 9;
      height: auto;
      display: block;
    }

    .sliders{
      width: 100%;
      display:grid;
      gap: 6px;
      box-sizing: border-box;
      margin-top: 8px;
    }

    .row{
      display: grid;
      grid-template-columns: var(--pl) var(--lw) 1fr var(--vw) var(--pr);
      column-gap: 0px;
      align-items: center;
      width: 100%;
      box-sizing: border-box;
    }

    .row .lbl{ grid-column: 2; }
    .row input[type="range"]{ grid-column: 3; width: 100%; min-width: 0; }
    .row .val{ grid-column: 4; text-align: right; }

    .lbl{
      font-size: var(--ui-font);
      font-weight: 400;
      color: var(--fg);
      user-select:none;
      white-space: nowrap;
    }

    .val{
      text-align:center;
      font-variant-numeric: tabular-nums;
      font-size: var(--ui-font);
      font-weight: 400;
      color: var(--fg);
      user-select:none;
      white-space: nowrap;
    }

    input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      height: 5px;
      border-radius: 999px;
      background: var(--track);
      outline:none;
      margin: 0;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height: 12px;
      border-radius: 999px;
      background: var(--track);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: var(--thumb);
      border: 3px solid var(--thumb-ring);
      box-shadow: 0 5px 12px rgba(0,0,0,0.18);
      cursor:pointer;
      margin-top: -7px;
    }

    input[type="range"]::-moz-range-track{
      height: 12px;
      border-radius: 999px;
      background: var(--track);
    }
    input[type="range"]::-moz-range-thumb{
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: var(--thumb);
      border: 3px solid var(--thumb-ring);
      box-shadow: 0 5px 12px rgba(0,0,0,0.18);
      cursor:pointer;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="plot-card">
      <canvas id="plot" width="1200" height="675" aria-label="Amplitude and phase vs frequency ratio"></canvas>
    </div>

    <div class="sliders">
      <div class="row">
        <div class="lbl">ζ</div>
        <input id="zeta" type="range" min="0" max="1.0" step="0.01" value="0.10" />
        <div class="val" id="zetaVal">0.10</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("plot");
  const ctx = canvas.getContext("2d");

  const zetaEl = document.getElementById("zeta");
  const zetaValEl = document.getElementById("zetaVal");

  const R_MIN = 0.0;
  const R_MAX = 3.0;

  // === Edit these to customize labels/spacing ===
  // Gap (in pixels) between the left and right panels:

  // Panel layout
  // GAP controls horizontal spacing between the left and right panels (in pixels):
  const GAP = 0;
  const MARG = {l: 90, r: 22, t: 26, b: 76};

  // Axis labels (edit these strings to change what appears on the axes)
  const X_LABEL = "r = ω_f/ω_n";
  const Y_LABEL_LEFT = "A/(f_0/k)";
  const Y_LABEL_RIGHT = "φ (deg)";

  function cssVarPx(name){
    return parseFloat(getComputedStyle(document.documentElement).getPropertyValue(name));
  }

  function fmt2(x){
    const y = (Math.abs(x) < 5e-5) ? 0 : x;
    return y.toFixed(2);
  }

  function niceTickStep(span, targetTicks){
    // "nice" step sizes: 1, 2, 2.5, 5 × 10^n
    const raw = span / targetTicks;
    const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
    const n = raw / pow10;
    let step;
    if (n < 1.5) step = 1;
    else if (n < 2.25) step = 2;
    else if (n < 3.5) step = 2.5;
    else if (n < 7.5) step = 5;
    else step = 10;
    return step * pow10;
  }


  const FONT_FAMILY = "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif";

  function drawTextSub(text, x, y, baseSize, align="left", baseline="alphabetic"){
    // Minimal subscript rendering for canvas text.
    // Uses underscore notation: "ω_f" draws 'f' as a subscript; underscore itself is not drawn.
    const subScale = 0.65;
    const subOffset = 0.35 * baseSize;

    // Parse runs
    const runs = [];
    for (let i = 0; i < text.length; i++){
      const ch = text[i];
      if (ch === "_" && i < text.length - 1){
        runs.push({ ch: text[i + 1], sub: true });
        i++;
      } else {
        runs.push({ ch, sub: false });
      }
    }

    // Measure total width
    let wTotal = 0;
    for (const r of runs){
      const sz = r.sub ? baseSize * subScale : baseSize;
      ctx.font = `${sz}px ${FONT_FAMILY}`;
      wTotal += ctx.measureText(r.ch).width;
    }

    let x0 = x;
    if (align === "center") x0 -= wTotal / 2;
    else if (align === "right") x0 -= wTotal;

    // Draw
    ctx.textAlign = "left";
    ctx.textBaseline = baseline;
    for (const r of runs){
      const sz = r.sub ? baseSize * subScale : baseSize;
      const yOff = r.sub ? subOffset : 0;
      ctx.font = `${sz}px ${FONT_FAMILY}`;
      ctx.fillText(r.ch, x0, y + yOff);
      x0 += ctx.measureText(r.ch).width;
    }
  }


  function drawPanel(panelX0, panelW, panelH, opts){
    const { yMin, yMax, yTicksFixed, title, yLabel, xLabel, curveXY } = opts;

    const m = MARG;
    const pw = panelW - m.l - m.r;
    const ph = panelH - m.t - m.b;

    const xToPix = (x) => panelX0 + m.l + ((x - R_MIN) / (R_MAX - R_MIN)) * pw;
    const yToPix = (y) => m.t + ((yMax - y) / (yMax - yMin)) * ph;

    // Grid
    ctx.save();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--grid").trim();
    ctx.lineWidth = 1.5;
    ctx.lineCap = "butt";

    // x ticks (fixed)
    const NX = 6; // 0..3 by 0.5
    const xStep = (R_MAX - R_MIN) / NX;
    const xTicks = [];
    for (let i=0;i<=NX;i++) xTicks.push(R_MIN + i*xStep);
    for (const xt of xTicks){
      const xp = xToPix(xt);
      ctx.beginPath();
      ctx.moveTo(xp, yToPix(yMin));
      ctx.lineTo(xp, yToPix(yMax));
      ctx.stroke();
    }

    // y ticks
    let yTicks = [];
    if (yTicksFixed && yTicksFixed.length){
      yTicks = yTicksFixed.slice();
    } else {
      const yStep = niceTickStep((yMax - yMin), 4);
      const yStart = Math.floor(yMin / yStep) * yStep;
      const yEnd   = Math.ceil(yMax / yStep) * yStep;
      for (let yt = yStart; yt <= yEnd + 1e-12; yt += yStep){
        if (yt >= yMin - 1e-12 && yt <= yMax + 1e-12) yTicks.push(yt);
      }
    }
    for (const yt of yTicks){
      const yp = yToPix(yt);
      ctx.beginPath();
      ctx.moveTo(xToPix(R_MIN), yp);
      ctx.lineTo(xToPix(R_MAX), yp);
      ctx.stroke();
    }
    ctx.restore();

    // Axes rectangle
    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2.2;
    ctx.strokeRect(panelX0 + m.l, m.t, pw, ph);
    ctx.restore();

    // Tick labels
    const tickFont = cssVarPx("--tick-font");
    const axisFont = cssVarPx("--axis-font");

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.font = `${tickFont}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;

    // x tick labels
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    for (const xt of xTicks){
      const xp = xToPix(xt);
      const t = (Math.abs(xt) < 5e-6) ? "0" : xt.toFixed(1);
      ctx.fillText(t, xp, m.t + ph + 10);
    }

    // y tick labels
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for (const yt of yTicks){
      const yp = yToPix(yt);
      let t;
      if (Math.abs(yt) < 5e-6) t = "0";
      else if (Math.abs(yt) >= 100) t = yt.toFixed(0);
      else if (Math.abs(yt) >= 10) t = yt.toFixed(0);
      else if (Math.abs(yt) >= 1) t = yt.toFixed(1);
      else t = yt.toFixed(2);
      ctx.fillText(t, panelX0 + m.l - 10, yp);
    }

    // Axis labels
    ctx.fillStyle = "#000";
    ctx.font = `${axisFont}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;

    // x label
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    drawTextSub(xLabel, panelX0 + m.l + pw/2, m.t + ph + 54, axisFont, "center", "alphabetic");

    // y label (rotated)
    ctx.save();
    ctx.translate(panelX0 + 32, m.t + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    drawTextSub(yLabel, 0, 0, axisFont, "center", "alphabetic");
    ctx.restore();


    ctx.restore();

    // Curve (clipped)
    ctx.save();
    ctx.beginPath();
    ctx.rect(panelX0 + m.l, m.t, pw, ph);
    ctx.clip();

    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 4.0;
    ctx.lineJoin = "round";
    ctx.lineCap  = "round";
    ctx.setLineDash([]);

    const pts = curveXY;
    ctx.beginPath();
    for (let i=0;i<pts.length;i++){
      const [x,y] = pts[i];
      const xp = xToPix(x);
      const yp = yToPix(y);
      if (i===0) ctx.moveTo(xp, yp);
      else ctx.lineTo(xp, yp);
    }
    ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  function computeCurves(zeta){
    const N = 1200;
    const amp = [];
    const phs = [];

    // amplitude ratio peak at r=1 is 1/(2ζ) (for ζ>0)
    const zEff = Math.max(zeta, 1e-4);

    for (let i=0;i<N;i++){
      const r = R_MIN + (R_MAX - R_MIN) * (i/(N-1));
      const denom = Math.sqrt(Math.pow(1 - r*r, 2) + Math.pow(2*zeta*r, 2));
      let H;
      if (zeta === 0){
        // undamped: H = 1/|1-r^2|, clip for display
        const d = Math.abs(1 - r*r);
        H = (d < 1e-6) ? 1e6 : 1/d;
      } else {
        H = 1/denom;
      }

      // phase lag
      let phi = Math.atan2(2*zeta*r, (1 - r*r)); // radians
      let phiDeg = phi * 180 / Math.PI;

      amp.push([r, H]);
      phs.push([r, phiDeg]);
    }
    return {amp, phs};
  }

  function draw(){
    const W = canvas._cssW;
    const H = canvas._cssH;

    const zeta = parseFloat(zetaEl.value);
    zetaValEl.textContent = fmt2(zeta);

    ctx.clearRect(0, 0, W, H);

    const panelW = (W - GAP) / 2;
    const panelH = H;

    const {amp, phs} = computeCurves(zeta);

    // Dynamic y-range for amplitude ratio
    // Peak at r=1 is 1/(2ζ). Choose ymax to show the peak but cap it.
    let yMaxAmp;
    if (zeta <= 1e-6){
      yMaxAmp = 20;
    } else {
      yMaxAmp = Math.min(20, Math.max(2, 1.15 * (1/(2*zeta))));
    }
    const yMinAmp = 0;

    // Clip amplitude curve to yMaxAmp (for display)
    const ampClipped = amp.map(([r,h]) => [r, Math.min(h, yMaxAmp)]);

    // Phase range fixed
    const yMinPhi = 0;
    const yMaxPhi = 180;
    const phiTicks = [0, 45, 90, 135, 180];

    drawPanel(0, panelW, panelH, {
      yMin: yMinAmp,
      yMax: yMaxAmp,
      yTicksFixed: null,
      title: "",
      yLabel: Y_LABEL_LEFT,
      xLabel: X_LABEL,
      curveXY: ampClipped
    });

    drawPanel(panelW + GAP, panelW, panelH, {
      yMin: yMinPhi,
      yMax: yMaxPhi,
      yTicksFixed: phiTicks,
      title: "",
      yLabel: Y_LABEL_RIGHT,
      xLabel: X_LABEL,
      curveXY: phs
    });
  }

  function resizeCanvasToCSSPixels(){
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(10, Math.round(rect.width));
    const cssH = Math.max(10, Math.round(rect.height));
    canvas._cssW = cssW;
    canvas._cssH = cssH;

    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    draw();
  }

  zetaEl.addEventListener("input", draw);
  window.addEventListener("resize", resizeCanvasToCSSPixels);

  resizeCanvasToCSSPixels();
})();

function postIframeHeight(){
  const h = document.documentElement.scrollHeight;
  window.parent.postMessage({ type: "quiz-iframe-height", height: h }, "*");
}

window.addEventListener("load", () => {
  postIframeHeight();
  requestAnimationFrame(postIframeHeight);
});

new ResizeObserver(postIframeHeight).observe(document.documentElement);
</script>
</body>
</html>
