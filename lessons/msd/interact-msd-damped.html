<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mass-Spring-Damper Interact</title>
  <style>
    :root{
      --bg: #ffffff;
      --fg: #000000;
      --grid: rgba(0,0,0,0.18);     /* thin light-gray grid */
      --axis: rgba(0,0,0,0.95);
      --muted: rgba(0,0,0,0.70);

      /* sliders */
      --track: #a9cff2;
      --thumb: #0c5a78;
      --thumb-ring: #08394b;
      --pl: 80px;   /* left padding */
      --lw: 40px;   /* label width */
      --vw: 50px;   /* value width */
      --pr: 20px;    /* right padding */

      /* font sizes */
        --ui-font: 24px;     /* sliders (DOM text) */
        --tick-font: 20px;   /* canvas tick numbers */
        --axis-font: 24px;   /* canvas axis labels */
    }

    /* html,body{height:100%;} */
    html, body { height: auto; }
    body{
      margin:0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      /* display:flex; */
      justify-content:center;
      align-items:flex-start;
    }


    /* One shared width for plot + sliders (including labels/values) */
    .wrap{
      width: min(980px, 94vw);
      padding: 22px 10px 26px;
      box-sizing: border-box;
    }

    .plot-card{
      width: 100%;
      display:flex;
      justify-content:center;
      align-items:center;
      padding: 0 0 0px;
      box-sizing: border-box;
    }

    canvas{
      width: 100%;
      aspect-ratio: 3 / 2;  /* width : height = 1.5 : 1 */
      height: auto;         /* let aspect-ratio control height */
      display: block;
    }

    .sliders{
      width: 100%;
      display:grid;
      gap: 6px;
      box-sizing: border-box;
    }

    .row{
        display: grid;
        grid-template-columns: var(--pl) var(--lw) 1fr var(--vw) var(--pr);
        column-gap: 0px;
        align-items: center;
        width: 100%;
        box-sizing: border-box;
    }

    /* Place elements into specific columns */
    .row .lbl{ grid-column: 2; }
    .row input[type="range"]{ grid-column: 3; width: 100%; min-width: 0; }
    .row .val{ grid-column: 4; text-align: right; }

    .lbl{
        font-size: var(--ui-font);
        font-weight: 400;
        color: var(--fg);
        user-select:none;
        white-space: nowrap;
    }

    .val{
      text-align:center;
      font-variant-numeric: tabular-nums;
      font-size: var(--ui-font);
      font-weight: 400;
      color: var(--fg);
      user-select:none;
      white-space: nowrap;
    }

    input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      height: 5px;
      border-radius: 999px;
      background: var(--track);
      outline:none;
      margin: 0;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height: 12px;
      border-radius: 999px;
      background: var(--track);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: var(--thumb);
      border: 3px solid var(--thumb-ring);
      box-shadow: 0 5px 12px rgba(0,0,0,0.18);
      cursor:pointer;
      margin-top: -7px; /* center on 12px track */
    }

    input[type="range"]::-moz-range-track{
      height: 12px;
      border-radius: 999px;
      background: var(--track);
    }
    input[type="range"]::-moz-range-thumb{
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: var(--thumb);
      border: 3px solid var(--thumb-ring);
      box-shadow: 0 5px 12px rgba(0,0,0,0.18);
      cursor:pointer;
    }

  </style>
</head>
<body>
  <div class="wrap">
    <div class="plot-card">
      <canvas id="plot" width="1200" height="700" aria-label="SHM plot"></canvas>
    </div>

    <div class="sliders">
      <div class="row">
        <div class="lbl">y₀</div>
        <input id="y0" type="range" min="-2" max="2" step="0.1" value="1.0" />
        <div class="val" id="y0Val">1.00</div>
      </div>

      <div class="row">
        <div class="lbl">v₀</div>
        <input id="v0" type="range" min="-2" max="2" step="0.1" value="0.0" />
        <div class="val" id="v0Val">0.00</div>
      </div>

      <div class="row">
        <div class="lbl">ωₙ</div>
        <input id="wn" type="range" min="0" max="5" step="0.1" value="3.0" />
        <div class="val" id="wnVal">1.00</div>
      </div>

      <div class="row">
        <div class="lbl">ζ</div>
        <input id="zeta" type="range" min="0" max="2" step="0.1" value="0.2" />
        <div class="val" id="zetaVal">0.20</div>
      </div>
      
      <div class="row">
        <div class="lbl">β</div>
        <input id="beta" type="range" min="0" max="6" step="0.1" value="0.1" />
        <div class="val" id="betaVal">0.60</div>
      </div>




    </div>
  </div>

<script>
(() => {
  // ODE: y'' + 2 ζ ω_n y' + ω_n^2 y = 0
  // IC: y(0)=y0, y'(0)=v0

  const T_MIN = 0.0;
  const T_MAX = 10.0;

  // Grid / ticks: "numbered outside axes"
  const NX = 4;        // number of x-intervals (=> NX+1 tick labels)
  const NY = 4;        // number of y-intervals

  // y-limits: fixed range
  const Y_MIN_FIXED = -1.0;
  const Y_MAX_FIXED =  1.0;

  const canvas = document.getElementById("plot");
  const ctx = canvas.getContext("2d");

  const y0El = document.getElementById("y0");
  const v0El = document.getElementById("v0");
  const wnEl = document.getElementById("wn");
  const zetaEl = document.getElementById("zeta");
  const betaEl = document.getElementById("beta");

  const y0ValEl = document.getElementById("y0Val");
  const v0ValEl = document.getElementById("v0Val");
  const wnValEl = document.getElementById("wnVal");
  const zetaValEl = document.getElementById("zetaVal");
  const betaValEl = document.getElementById("betaVal");

  function cssVarPx(name){
    return parseFloat(getComputedStyle(document.documentElement).getPropertyValue(name));
  }

  function fmt(x){
    const y = (Math.abs(x) < 5e-4) ? 0 : x;
    return y.toFixed(1);
  }

  function niceTickStep(span, n){
    // very small "nice numbers" helper: 1,2,5 * 10^k
    const raw = span / n;
    const k = Math.pow(10, Math.floor(Math.log10(raw)));
    const r = raw / k;
    let m;
    if (r < 1.5) m = 1;
    else if (r < 3.5) m = 2;
    else if (r < 7.5) m = 5;
    else m = 10;
    return m * k;
  }

  function computeY(t, y0, v0, wn, zeta){
    // Handles under/critical/over damped cases.
    if (Math.abs(wn) < 1e-6) return y0 + v0 * t;

    const eps = 1e-6;

    if (zeta < 1.0 - eps){
      // underdamped
      const wd = wn * Math.sqrt(1.0 - zeta*zeta);
      const A = y0;
      const B = (v0 + zeta*wn*y0) / wd;
      return Math.exp(-zeta*wn*t) * (A*Math.cos(wd*t) + B*Math.sin(wd*t));
    } else if (zeta > 1.0 + eps){
      // overdamped
      const s = Math.sqrt(zeta*zeta - 1.0);
      const r1 = -wn * (zeta - s);
      const r2 = -wn * (zeta + s);
      const A = (v0 - r2*y0) / (r1 - r2);
      const B = (r1*y0 - v0) / (r1 - r2);
      return A*Math.exp(r1*t) + B*Math.exp(r2*t);
    } else {
      // critically damped (ζ ≈ 1)
      const a1 = y0;
      const a2 = v0 + wn*y0;
      return (a1 + a2*t) * Math.exp(-wn*t);
    }
  }

  function computeEnvelopeAmplitude(y0, v0, wn, zeta){
    // Reference decay curves: ± a * exp(-ω_n ζ t)
    //
    // For ζ < 1, the *oscillatory* part can be written as:
    //   y(t) = exp(-ζ ω_n t) [ A cos(ω_d t) + B sin(ω_d t) ]
    // with envelope amplitude a_ud = sqrt(A^2 + B^2).
    //
    // But as ζ → 1⁻, ω_d → 0 and B ~ (v0 + ζ ω_n y0)/ω_d, so a_ud blows up
    // even though the true solution remains finite (it becomes non-oscillatory).
    //
    // To keep the dashed "decay rate" curve visually meaningful and continuous
    // through ζ = 1, we:
    //   - use the underdamped envelope amplitude when we're comfortably underdamped
    //   - blend smoothly to a stable "energy amplitude" near critical damping
    //   - use that stable amplitude for ζ ≥ 1.
    const wnAbs = Math.abs(wn);
    const epsWn = 1e-9;
    if (wnAbs < epsWn) return Math.abs(y0);

    // Stable amplitude based on initial energy scaling (finite for all ζ)
    const aStable = Math.max(Math.abs(y0), Math.abs(v0) / wnAbs);

    // Underdamped envelope amplitude (only meaningful away from ζ ≈ 1)
    let aUD = aStable;
    if (zeta < 1.0){
      const oneMinus = 1.0 - zeta*zeta;
      if (oneMinus > 0.0){
        const wd = wnAbs * Math.sqrt(oneMinus);
        // Avoid the ω_d → 0 blow-up by only using aUD when ω_d isn't too small
        if (wd > 0.15 * wnAbs){
          const A = y0;
          const B = (v0 + zeta*wn*y0) / (wn >= 0 ? wd : -wd); // keep sign consistent with wn
          aUD = Math.sqrt(A*A + B*B);
        }
      }
    }

    // Cap extreme values (prevents spikes as ζ → 1⁻)
    const CAP = 4.0;
    aUD = Math.min(aUD, CAP * aStable);

    // Smooth blend to stable amplitude as ζ approaches 1
    const zBlend0 = 0.85; // start blending here
    const zBlend1 = 1.00; // fully stable at ζ = 1
    if (zeta <= zBlend0) return aUD;
    if (zeta >= zBlend1) return aStable;

    let u = (zeta - zBlend0) / (zBlend1 - zBlend0);
    // smoothstep
    u = u*u*(3 - 2*u);

    return (1 - u)*aUD + u*aStable;
  }

  function computeEnvelope(t, a, rate){
    return a * Math.exp(-rate*t);
  }

  function draw(){
    const W = canvas._cssW;
    const H = canvas._cssH;

    const y0 = parseFloat(y0El.value);
    const v0 = parseFloat(v0El.value);
    const wn = parseFloat(wnEl.value);
    const zeta = parseFloat(zetaEl.value);
    const beta = parseFloat(betaEl.value);

    y0ValEl.textContent = fmt(y0);
    v0ValEl.textContent = fmt(v0);
    wnValEl.textContent = fmt(wn);
    zetaValEl.textContent = fmt(zeta);
    betaValEl.textContent = fmt(beta);

    // Hidden "correct" decay rate (depends on ωₙ and ζ)
    const alpha = wn * zeta;
    // Reference decay envelope (shown for all ζ)
    const aEnv = computeEnvelopeAmplitude(y0, v0, wn, zeta);
    // const showEnv = true;
    const epsEnv = 1e-6;
    const showEnv = (zeta < 1.0 - epsEnv);


    // Fixed y-limits
    const yMin = Y_MIN_FIXED;
    const yMax = Y_MAX_FIXED;

    // Layout margins (leave space for outside tick labels + axis labels)
    const m = {l: 90, r: 28, t: 22, b: 60};
    const pw = W - m.l - m.r;
    const ph = H - m.t - m.b;

    ctx.clearRect(0, 0, W, H);

    // Helpers mapping
    const xToPix = (t) => m.l + ((t - T_MIN)/(T_MAX - T_MIN)) * pw;
    const yToPix = (y) => m.t + ((yMax - y)/(yMax - yMin)) * ph;

    // Draw grid behind curves
    ctx.save();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--grid").trim();
    ctx.lineWidth = 1.5;
    ctx.lineCap = "butt";

    // Choose tick positions
    const xStep = (T_MAX - T_MIN) / NX;
    // For y, use "nice" step based on span
    const yStep = niceTickStep((yMax - yMin), NY);

    // Snap y ticks around 0-ish region
    const yTickStart = Math.floor(yMin / yStep) * yStep;
    const yTickEnd   = Math.ceil(yMax / yStep) * yStep;

    // Vertical gridlines + x tick labels
    const xTicks = [];
    for (let i = 0; i <= NX; i++){
      xTicks.push(T_MIN + i * xStep);
    }
    for (const xt of xTicks){
      const xp = xToPix(xt);
      ctx.beginPath();
      ctx.moveTo(xp, yToPix(yMin));
      ctx.lineTo(xp, yToPix(yMax));
      ctx.stroke();
    }

    // Horizontal gridlines + y tick labels
    const yTicks = [];
    for (let yt = yTickStart; yt <= yTickEnd + 1e-12; yt += yStep){
      // keep only visible ticks
      if (yt >= yMin - 1e-12 && yt <= yMax + 1e-12) yTicks.push(yt);
    }
    for (const yt of yTicks){
      const yp = yToPix(yt);
      ctx.beginPath();
      ctx.moveTo(xToPix(T_MIN), yp);
      ctx.lineTo(xToPix(T_MAX), yp);
      ctx.stroke();
    }
    ctx.restore();

    // Axes rectangle (thin black, above grid)
    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2.2;
    ctx.strokeRect(m.l, m.t, pw, ph);
    ctx.restore();

    const tickFont = cssVarPx("--tick-font");
    const axisFont = cssVarPx("--axis-font");

    // Tick labels (outside axes)
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.font = `${tickFont}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    // x tick labels under axis
    for (const xt of xTicks){
      const xp = xToPix(xt);
      const txt = (Math.abs(xt) < 5e-4) ? "0" : xt.toFixed(1);
      ctx.fillText(txt, xp, m.t + ph + 10);
    }

    // y tick labels left of axis
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for (const yt of yTicks){
      const yp = yToPix(yt);
      const txt = (Math.abs(yt) < 5e-4) ? "0" : yt.toFixed(1);
      ctx.fillText(txt, m.l - 10, yp);
    }

    // Axis labels: t (x-axis) and y (y-axis)
    ctx.fillStyle = "#000";
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    ctx.font = `${axisFont}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    ctx.fillText("t", m.l + pw/2, m.t + ph + 52);

    // y label rotated
    ctx.save();
    ctx.translate(30, m.t + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    ctx.fillText("y", 0, 0);
    ctx.restore();

    ctx.restore();

    const N = 1100;

    // Clip curves to the plot window
    ctx.save();
    ctx.beginPath();
    ctx.rect(m.l, m.t, pw, ph);
    ctx.clip();

    // Dashed reference curves: "correct" ± a e^{-α t} (black) and user ± a e^{-β t} (red)
    if (showEnv){
      // Correct envelope (black dashed): ± a e^{-α t}
      ctx.save();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3.0;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      ctx.setLineDash([10, 8]);

      // + envelope
      ctx.beginPath();
      for (let k = 0; k <= N; k++){
        const t = T_MIN + (k/N) * (T_MAX - T_MIN);
        const y = computeEnvelope(t, aEnv, alpha);
        const xp = xToPix(t);
        const yp = yToPix(y);
        if (k === 0) ctx.moveTo(xp, yp);
        else ctx.lineTo(xp, yp);
      }
      ctx.stroke();

      // - envelope
      ctx.beginPath();
      for (let k = 0; k <= N; k++){
        const t = T_MIN + (k/N) * (T_MAX - T_MIN);
        const y = -computeEnvelope(t, aEnv, alpha);
        const xp = xToPix(t);
        const yp = yToPix(y);
        if (k === 0) ctx.moveTo(xp, yp);
        else ctx.lineTo(xp, yp);
      }
      ctx.stroke();

      ctx.restore();

      // User envelope (red dashed): ± a e^{-β t}
      ctx.save();
      ctx.strokeStyle = "#cc0000";
      ctx.lineWidth = 3.0;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      ctx.setLineDash([10, 8]);

      // + envelope
      ctx.beginPath();
      for (let k = 0; k <= N; k++){
        const t = T_MIN + (k/N) * (T_MAX - T_MIN);
        const y = computeEnvelope(t, aEnv, beta);
        const xp = xToPix(t);
        const yp = yToPix(y);
        if (k === 0) ctx.moveTo(xp, yp);
        else ctx.lineTo(xp, yp);
      }
      ctx.stroke();

      // - envelope
      ctx.beginPath();
      for (let k = 0; k <= N; k++){
        const t = T_MIN + (k/N) * (T_MAX - T_MIN);
        const y = -computeEnvelope(t, aEnv, beta);
        const xp = xToPix(t);
        const yp = yToPix(y);
        if (k === 0) ctx.moveTo(xp, yp);
        else ctx.lineTo(xp, yp);
      }
      ctx.stroke();

      ctx.restore();
    }
// Solid curve on top: full solution
    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 3.0;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.setLineDash([]);

    ctx.beginPath();
    for (let k = 0; k <= N; k++){
      const t = T_MIN + (k/N) * (T_MAX - T_MIN);
      const y = computeY(t, y0, v0, wn, zeta);
      const xp = xToPix(t);
      const yp = yToPix(y);
      if (k === 0) ctx.moveTo(xp, yp);
      else ctx.lineTo(xp, yp);
    }
    ctx.stroke();
    ctx.restore();

    // End clipping region
    ctx.restore();

    // Legend (dashed envelopes)
    if (showEnv){
      ctx.save();

      const legendText1 = "± a·exp(−α t)";
      const legendText2 = "± a·exp(−β t)";

      ctx.font = `${tickFont}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;

      const pad = 10;
      const lineLen = 44;
      const gap = 12;
      const rowGap = 10;

      const textW = Math.max(
        ctx.measureText(legendText1).width,
        ctx.measureText(legendText2).width
      );

      const boxH = pad*2 + 2*tickFont + rowGap;
      const boxW = pad*2 + lineLen + gap + textW;

      const x0 = m.l + pw - boxW - 12;
      const y0b = m.t + 12;

      ctx.fillStyle = "rgba(255,255,255,0.90)";
      ctx.fillRect(x0, y0b, boxW, boxH);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1.5;
      ctx.strokeRect(x0, y0b, boxW, boxH);

      const y1 = y0b + pad + tickFont/2;
      const y2 = y1 + tickFont + rowGap;

      // Entry 1: black dashed (correct)
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3.0;
      ctx.setLineDash([10, 8]);
      ctx.beginPath();
      ctx.moveTo(x0 + pad, y1);
      ctx.lineTo(x0 + pad + lineLen, y1);
      ctx.stroke();

      ctx.setLineDash([]);
      ctx.fillStyle = "#000";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(legendText1, x0 + pad + lineLen + gap, y1);

      // Entry 2: red dashed (user)
      ctx.strokeStyle = "#cc0000";
      ctx.lineWidth = 3.0;
      ctx.setLineDash([10, 8]);
      ctx.beginPath();
      ctx.moveTo(x0 + pad, y2);
      ctx.lineTo(x0 + pad + lineLen, y2);
      ctx.stroke();

      ctx.setLineDash([]);
      ctx.fillStyle = "#000";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(legendText2, x0 + pad + lineLen + gap, y2);

      ctx.restore();
    }
}

  function resizeCanvasToCSSPixels(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();

    // CSS pixel size
    const cssW = rect.width;
    const cssH = rect.height;

    // Set internal pixel buffer
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);

    // Make drawing commands use CSS pixels
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Store CSS sizes for drawing
    canvas._cssW = cssW;
    canvas._cssH = cssH;

    draw();
  }

  [y0El, v0El, wnEl, zetaEl, betaEl].forEach(el => el.addEventListener("input", draw));
  window.addEventListener("resize", resizeCanvasToCSSPixels);

  resizeCanvasToCSSPixels();
})();

function postIframeHeight(){
  const h = document.documentElement.scrollHeight;
  window.parent.postMessage({ type: "quiz-iframe-height", height: h }, "*");
}

window.addEventListener("load", () => {
  postIframeHeight();
  requestAnimationFrame(postIframeHeight); // catches late layout (fonts/canvas)
});

// Keep it updated if canvas size changes with width
new ResizeObserver(postIframeHeight).observe(document.documentElement);

</script>
</body>
</html>


