<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mass-Spring Interact</title>
  <style>
    :root{
      --bg: #ffffff;
      --fg: #000000;
      --grid: rgba(0,0,0,0.18);     /* thin light-gray grid */
      --axis: rgba(0,0,0,0.95);
      --muted: rgba(0,0,0,0.70);

      /* sliders */
      --track: #a9cff2;
      --thumb: #0c5a78;
      --thumb-ring: #08394b;
      --pl: 80px;   /* left padding */
      --lw: 40px;   /* label width */
      --vw: 50px;   /* value width */
      --pr: 20px;    /* right padding */

      /* font sizes */
        --ui-font: 24px;     /* sliders (DOM text) */
        --tick-font: 20px;   /* canvas tick numbers */
        --axis-font: 24px;   /* canvas axis labels */
    }

    /* html,body{height:100%;} */
    html, body { height: auto; }
    body{
      margin:0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      /* display:flex; */
      justify-content:center;
      align-items:flex-start;
    }


    /* One shared width for plot + sliders (including labels/values) */
    .wrap{
      width: min(980px, 94vw);
      padding: 22px 10px 26px;
      box-sizing: border-box;
    }

    .plot-card{
      width: 100%;
      display:flex;
      justify-content:center;
      align-items:center;
      padding: 0 0 0px;
      box-sizing: border-box;
    }

    /* canvas{
      width: 100%;
      height: min(520px, 200vh);
      display:block;
      background: transparent;
    } */
    canvas{
      width: 100%;
      aspect-ratio: 3 / 2;  /* width : height = 1.5 : 1 */
      height: auto;         /* let aspect-ratio control height */
      display: block;
    }


    .sliders{
      width: 100%;
      display:grid;
      gap: 14px;
      box-sizing: border-box;
    }

    .row{
        display: grid;
        grid-template-columns: var(--pl) var(--lw) 1fr var(--vw) var(--pr);
        column-gap: 0px;
        align-items: center;
        width: 100%;
        box-sizing: border-box;
    }

    /* Place elements into specific columns */
    .row .lbl{ grid-column: 2; }
    .row input[type="range"]{ grid-column: 3; width: 100%; min-width: 0; }
    .row .val{ grid-column: 4; text-align: right; }

    .lbl{
        font-size: var(--ui-font);
        font-weight: 400;
        color: var(--fg);
        user-select:none;
        white-space: nowrap;
    }

    .val{
      text-align:center;
      font-variant-numeric: tabular-nums;
      font-size: var(--ui-font);
      font-weight: 400;
      color: var(--fg);
      user-select:none;
      white-space: nowrap;
    }

    input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      height: 5px;
      border-radius: 999px;
      background: var(--track);
      outline:none;
      margin: 0;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height: 12px;
      border-radius: 999px;
      background: var(--track);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: var(--thumb);
      border: 3px solid var(--thumb-ring);
      box-shadow: 0 5px 12px rgba(0,0,0,0.18);
      cursor:pointer;
      margin-top: -7px; /* center on 12px track */
    }

    input[type="range"]::-moz-range-track{
      height: 12px;
      border-radius: 999px;
      background: var(--track);
    }
    input[type="range"]::-moz-range-thumb{
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: var(--thumb);
      border: 3px solid var(--thumb-ring);
      box-shadow: 0 5px 12px rgba(0,0,0,0.18);
      cursor:pointer;
    }

  </style>
</head>
<body>
  <div class="wrap">
    <div class="plot-card">
      <canvas id="plot" width="1200" height="700" aria-label="SHM plot"></canvas>
    </div>

    <div class="sliders">
      <div class="row">
        <div class="lbl">y₀</div>
        <input id="y0" type="range" min="-2" max="2" step="0.1" value="1.0" />
        <div class="val" id="y0Val">1.00</div>
      </div>

      <div class="row">
        <div class="lbl">v₀</div>
        <input id="v0" type="range" min="-2" max="2" step="0.1" value="0.0" />
        <div class="val" id="v0Val">0.00</div>
      </div>

      <div class="row">
        <div class="lbl">ωₙ</div>
        <input id="wn" type="range" min="0" max="5" step="0.1" value="1.0" />
        <div class="val" id="wnVal">2.00</div>
      </div>


    </div>
  </div>

<script>
(() => {
  // ODE: y'' + ω_n^2 y = 0
  // IC solution: y(t) = y0 cos(ω_n t) + (v0/ω_n) sin(ω_n t)
  const T_MIN = 0.0;
  const T_MAX = 10.0;

  // Grid / ticks: "numbered outside axes"
  const NX = 4;        // number of x-intervals (=> NX+1 tick labels)
  const NY = 4;        // number of y-intervals

  // y-limits: keep stable but responsive
  const Y_SOFT = 2.0;
  const Y_PAD  = 0.35;

  const canvas = document.getElementById("plot");
  const ctx = canvas.getContext("2d");

  const y0El = document.getElementById("y0");
  const v0El = document.getElementById("v0");
  const wnEl = document.getElementById("wn");

  const y0ValEl = document.getElementById("y0Val");
  const v0ValEl = document.getElementById("v0Val");
  const wnValEl = document.getElementById("wnVal");

  function cssVarPx(name){
    return parseFloat(getComputedStyle(document.documentElement).getPropertyValue(name));
  }

  function fmt(x){
    const y = (Math.abs(x) < 5e-4) ? 0 : x;
    return y.toFixed(1);
  }
  function niceTickStep(span, n){
    // very small "nice numbers" helper: 1,2,5 * 10^k
    const raw = span / n;
    const k = Math.pow(10, Math.floor(Math.log10(raw)));
    const r = raw / k;
    let m;
    if (r < 1.5) m = 1;
    else if (r < 3.5) m = 2;
    else if (r < 7.5) m = 5;
    else m = 10;
    return m * k;
  }
  function computeY(t, y0, v0, wn){
    if (Math.abs(wn) < 1e-6) return y0 + v0 * t;
    return y0 * Math.cos(wn * t) + (v0 / wn) * Math.sin(wn * t);
  }

  function draw(){
    const W = canvas._cssW;
    const H = canvas._cssH;

    const y0 = parseFloat(y0El.value);
    const v0 = parseFloat(v0El.value);
    const wn = parseFloat(wnEl.value);

    y0ValEl.textContent = fmt(y0);
    v0ValEl.textContent = fmt(v0);
    wnValEl.textContent = fmt(wn);

    // Probe curve to set y limits gently
    let ymin = Infinity, ymax = -Infinity;
    const probeN = 600;
    for (let k = 0; k <= probeN; k++){
      const t = T_MIN + (k/probeN) * (T_MAX - T_MIN);
      const y = computeY(t, y0, v0, wn);
      ymin = Math.min(ymin, y);
      ymax = Math.max(ymax, y);
    }
    const center = 0.5 * (ymin + ymax);
    const span = Math.max(0.6, ymax - ymin);
    const yLim = Math.max(Y_SOFT, 0.5*span) + Y_PAD;
    const yMin = center - yLim;
    const yMax = center + yLim;

    // Layout margins (leave space for outside tick labels + axis labels)
    const m = {l: 90, r: 28, t: 22, b: 60};
    const pw = W - m.l - m.r;
    const ph = H - m.t - m.b;

    ctx.clearRect(0, 0, W, H);

    // Helpers mapping
    const xToPix = (t) => m.l + ((t - T_MIN)/(T_MAX - T_MIN)) * pw;
    const yToPix = (y) => m.t + ((yMax - y)/(yMax - yMin)) * ph;

    // Draw grid behind curve
    ctx.save();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--grid").trim();
    ctx.lineWidth = 1.5;
    ctx.lineCap = "butt";

    // Choose tick positions
    const xStep = (T_MAX - T_MIN) / NX;
    // For y, use "nice" step based on span
    const yStep = niceTickStep((yMax - yMin), NY);

    // Snap y ticks around 0-ish region
    const yTickStart = Math.floor(yMin / yStep) * yStep;
    const yTickEnd   = Math.ceil(yMax / yStep) * yStep;

    // Vertical gridlines + x tick labels
    const xTicks = [];
    for (let i = 0; i <= NX; i++){
      xTicks.push(T_MIN + i * xStep);
    }
    for (const xt of xTicks){
      const xp = xToPix(xt);
      ctx.beginPath();
      ctx.moveTo(xp, yToPix(yMin));
      ctx.lineTo(xp, yToPix(yMax));
      ctx.stroke();
    }

    // Horizontal gridlines + y tick labels
    const yTicks = [];
    for (let yt = yTickStart; yt <= yTickEnd + 1e-12; yt += yStep){
      // keep only visible ticks
      if (yt >= yMin - 1e-12 && yt <= yMax + 1e-12) yTicks.push(yt);
    }
    for (const yt of yTicks){
      const yp = yToPix(yt);
      ctx.beginPath();
      ctx.moveTo(xToPix(T_MIN), yp);
      ctx.lineTo(xToPix(T_MAX), yp);
      ctx.stroke();
    }
    ctx.restore();

    // Axes rectangle (thin black, above grid)
    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2.2;
    ctx.strokeRect(m.l, m.t, pw, ph);
    ctx.restore();

    const tickFont = cssVarPx("--tick-font");
    const axisFont = cssVarPx("--axis-font");

    // Tick labels (outside axes)
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.font = `${tickFont}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    // x tick labels under axis
    for (const xt of xTicks){
      const xp = xToPix(xt);
      const txt = (Math.abs(xt) < 5e-4) ? "0" : xt.toFixed(1);
      ctx.fillText(txt, xp, m.t + ph + 10);
    }

    // y tick labels left of axis
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for (const yt of yTicks){
      const yp = yToPix(yt);
      const txt = (Math.abs(yt) < 5e-4) ? "0" : yt.toFixed(1);
      ctx.fillText(txt, m.l - 10, yp);
    }

    // Axis labels: t (x-axis) and y (y-axis)
    ctx.fillStyle = "#000";
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    ctx.font = `${axisFont}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    ctx.fillText("t", m.l + pw/2, m.t + ph + 52);

    // y label rotated
    ctx.save();
    ctx.translate(30, m.t + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    ctx.fillText("y", 0, 0);
    ctx.restore();

    ctx.restore();

    // Curve on top
    ctx.save();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 3.0;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";

    const N = 1100;
    ctx.beginPath();
    for (let k = 0; k <= N; k++){
      const t = T_MIN + (k/N) * (T_MAX - T_MIN);
      const y = computeY(t, y0, v0, wn);
      const xp = xToPix(t);
      const yp = yToPix(y);
      if (k === 0) ctx.moveTo(xp, yp);
      else ctx.lineTo(xp, yp);
    }
    ctx.stroke();
    ctx.restore();
  }

  function resizeCanvasToCSSPixels(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();

    // CSS pixel size
    const cssW = rect.width;
    const cssH = rect.height;

    // Set internal pixel buffer
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);

    // Make drawing commands use CSS pixels
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Store CSS sizes for drawing
    canvas._cssW = cssW;
    canvas._cssH = cssH;

    draw();
  }


  [y0El, v0El, wnEl].forEach(el => el.addEventListener("input", draw));
  window.addEventListener("resize", resizeCanvasToCSSPixels);

  resizeCanvasToCSSPixels();
})();

function postIframeHeight(){
  const h = document.documentElement.scrollHeight;
  window.parent.postMessage({ type: "quiz-iframe-height", height: h }, "*");
}

window.addEventListener("load", () => {
  postIframeHeight();
  requestAnimationFrame(postIframeHeight); // catches late layout (fonts/canvas)
});

// Keep it updated if canvas size changes with width
new ResizeObserver(postIframeHeight).observe(document.documentElement);

</script>
</body>
</html>


